[transition="slide-in fade-out"]
== Comment afficher la liste des cartes cadeaux ?

[.same]
- Pagin√©e ü§î

[.notes]
--
- Effectivement comment on fait pour afficher une liste des cartes cadeaux avec quelques attributs, comme la boutique ou le code barre, et des infos d√©riv√©es comme le montant restant ?
- Alors que ce qu'on a stock√© ce sont des √©v√®nements unitaires, dont les informations cl√©s sont dans un payload.
- Relire tous les √©v√®nements pour reconstituer toutes les cartes cadeaux √† chaque fois para√Æt compliqu√©...
- Et si en plus la liste doit √™tre pagin√©e pour n'afficher que 10 cartes cadeaux √† la fois
 *click*
--

[transition="fade"]
=== Comment afficher la liste des cartes cadeaux ?

[.same]
- Pagin√©e ü§î
- Tri√©e üòÆ

[.notes]
--
ou tri√©e, par exemple par montant restant
*click*
--

[transition="fade-in slide-out"]
=== Comment afficher la liste des cartes cadeaux ?

[.same]
- Pagin√©e ü§î
- Tri√©e üòÆ
- Filtr√©e üò±

[.notes]
--
ou encore filtr√©e, par exemple sur la boutique...
--

[transition="fade-in slide-out"]
=== Une projection !

image::projection.png[]

[.notes]
--
- Pour r√©soudre ce probl√®me, on va utiliser une projection, √©galement appel√©e "query model", ou "read model" ou "mod√®le de lecture".
- Ce mod√®le va √™tre fabriqu√© sur mesure par rapport √† notre besoin en lecture, √† partir des √©v√®nements m√©tier.
- Dans ce cas pr√©cis, il va √™tre tr√®s similaire au mod√®le qu'on aurait eu en state-sourcing.
- Mais la grosse diff√©rence, c'est que c'est une information d√©riv√©e, qui peut √™tre amend√©e et recalcul√©e en fonction de l'√©volution des besoins.
- D'ailleurs dans notre impl√©mentation, les projections sont persist√©es avec des repositories in memory et recalcul√©es √† chaque red√©marrage de l'application. C'est tr√®s pratique au d√©but de l'application, cela offre une grande souplesse.
--

[%notitle]
[transition="slide-in fade-out"]
=== Illustration : 0st event

image::fold00.png[]

[.notes]
--
- Voyons ce que cela donne si on d√©roule notre histoire pas √† pas.
- Tant qu'aucun √©v√®nement n'a √©t√© appliqu√©, on n'a pas de projection.
--

[%notitle]
[transition="fade"]
=== Illustration : 1st event

image::fold01.png[]

[.notes]
--
- A partir de notre premier √©v√®nement, la d√©claration d'une carte, on va initialiser la projection avec :
- le code-barre,
- la boutique.
- Le montant restant qui sera √©gal au montant initial.
- Et le bool√©en qui indique que la carte n'est pas √©puis√©e.
--

[%notitle]
[transition="fade"]
=== Illustration : 2nd event

image::fold02.png[]

[.notes]
--
Ensuite lors d'un paiement, on va mettre √† jour le montant restant de la carte cadeau, en d√©duisant le montant du paiement.
--

[%notitle]
[transition="fade"]
=== Illustration : 3rd event

image::fold03.png[]

[.notes]
--
Nouveau paiement, on applique la m√™me logique
--

[%notitle]
[transition="fade-in slide-out"]
=== Illustration : 4rd event

image::fold04.png[]

[.notes]
--
- Enfin puisque la carte est √©puis√©e, on va mettre √† jour l'indicateur "exhausted" de la projection.
- Ce qui permettra de l'afficher de mani√®re distincte.
--

=== Code
üîç

=== Query Model

[source, java, highlight]
----
include::../../../src/main/java/io/craft/giftcard/giftcard/domain/projections/currentstate/GiftCardCurrentState.java[lines='12..18']
----

[.notes]
--
- C√¥te code, le mod√®le de lecture s'appelle GiftCardCurrentState
- Il contient les informations utiles pour l'affichage, le tri ou le filtrage
- Comment ce mod√®le est-il calcul√© ? Vous vous souvenez de ce que C√©dric disait pr√©c√©demment, que les events √©taient propag√© ?
--

=== Event publisher

[source, java, highlight="..|10..11"]
----
include::../../../src/main/java/io/craft/giftcard/giftcard/application/GiftCardApplicationService.java[lines='24..26,32..34,36..37,42..44,46']
----

[.notes]
--
- Et bien au niveau de l'EventPublisher, des events handlers vont venir s'abonner aux √©v√®nements.
--

=== Event handler

[source, java, highlight='..|5..9|11|7..8']
----
include::../../../src/main/java/io/craft/giftcard/giftcard/domain/projections/currentstate/GiftCardCurrentStateUpdater.java[lines='8..9,17..26']
----

[.notes]
--
- L'event handler associ√© √† notre projection va √™tre appel√© √† chaque fois qu'un √©v√©nement est √©mis,
- *click*
- et va pouvoir alors d√©terminer la nouvelle projection
- *click*
- et la sauvegarder.
- *click*
- Pour d√©terminer la nouvelle projection, on va distinguer deux types d'events : le premier, et les suivants
--

[%notitle]
=== Event handler: init

[source, java, highlight="3|4|2"]
----
include::../../../src/main/java/io/craft/giftcard/giftcard/domain/projections/currentstate/GiftCardCurrentStateUpdater.java[lines='8..9,28..30']
----

[source, java, highlight="3|4.."]
----
@QueryModel
public record GiftCardCurrentState(...) {

include::../../../src/main/java/io/craft/giftcard/giftcard/domain/projections/currentstate/GiftCardCurrentState.java[lines='19..27']
----

[.notes]
--
- C'est √† partir du 1er √©v√®nement de l'histoire, `GiftCardDeclared`, qu'on initialise la projection
- *click*
- En cr√©ant une nouvelle instance de `GiftCardCurrentState` √† partir des donn√©es de l'√©v√®nement
--

[%notitle]
=== Event handler: update

[source, java, highlight="3..|4..6|7|2"]
----
include::../../../src/main/java/io/craft/giftcard/giftcard/domain/projections/currentstate/GiftCardCurrentStateUpdater.java[lines='8..9,32..37']
----

[source, java, highlight="3|5,13|6..8|9"]
----
include::../../../src/main/java/io/craft/giftcard/giftcard/domain/projections/currentstate/GiftCardCurrentState.java[lines='12..13,35..47']
----

[.notes]
--
- Et pour chacun des √©v√®nements suivants, on va mettre √† jour le mod√®le de lecture.
- *click*
- Pour cela on charge l'√©tat courant du mod√®le,
- *click*
- on fait du pattern matching pour traiter de mani√®re exhaustive tous les types d'√©v√©nements
- *click*
- paiement
- *click*
- ou carte √©puis√©e
--
