== Choix du stockage

[.notes]
--
Qui dit nouveau projet dit choix de stockage des données.

on a plusieurs possibilités.

*click*
--

=== Sauvegarde d'état

[.notes]
--
La sauvegarde d'état c'est comme d'hab

On va stocker l'état de l'agregat, c'est-à-dire la dernière version.

Je vais prendre un exemple pour expliciter le truc

Imaginons vous avez...au hasard... des cartes cadeaux à gérer
--

[%notitle]
=== example statefull

[cols="5*", options="header"]
|===========================================
| barcode | shoppingStore | amount  |  last payment  | state
| 1234    | la redoute    | 90 €    |    _null_      | ONGOING
|===========================================

[.notes]
--
J'ai ça en base, si je paye 30 avec, j'obtiens ça
--

[%notitle]
=== example statefull

[cols="5*", options="header"]
|===========================================
| barcode | shoppingStore | amount   |  last payment | state
| 1234    | la redoute    | 60 €     |  2025-03-01   | ONGOING
|===========================================

[.notes]
--
Et si je dépense les 60 € restants
--

[%notitle]
=== example statefull

[cols="5*", options="header"]
|===========================================
| barcode | shoppingStore | amount |  last payment | state
| 1234    | la redoute    | 0 €    |  2025-03-10   | EXHAUSTED
|===========================================

[.notes]
--
ma carte cadeaux est vide et donc inutilisable.

ça c'est le fonctionnement classique de nos app.

on change l'état de notre objet à chaque fois qu'on lui applique un changement
--

=== Avantages

- Facile à comprendre
- Facile à lire
- On fait tout le temps comme ça

[.notes]
--
Les avantages de cette approche sont évidents.

- C'est facile à comprendre, on a un état et on le modifie
- C'est facile à lire, on veut savoir où on en est, on va voir l'état
- On fait tout le temps comme ça, c'est la manière dont on a appris à faire
--

=== Inconvénients

- Perte d'information
- Pas de traçabilité
- Obligation d'anticiper les besoins futurs

[.notes]
--
Par contre côté inconvénients, on a en top #1 la perte d'information.

et les autres qui en découlent, comme par exemple

pas de traçabilité, on sait où on en est mais on n'a aucune idée de comment on y est arrivé.

et on est obligé d'anticiper les besoins futurs,
si demain on veut savoir combien de fois j'ai utilisé ma carte cadeau, c'est mort.
Ou alors il faut le prévoir avant et incrémenter un compteur.

Parfois la perte d'information est acceptable, on peut clairement répondre au produit

> Ben le compteur d'utilisation il ne sera dispo quand pour les cartes à venir.
--

=== Sauvegarde d'événements

[.notes]
--
C'est un changement de paradigme.

On va stocker chaque événement qui a modifié l'état de notre agregat.
--


[%notitle.moresmaller]
=== example event sourcing

[cols="4*", options="header"]
|================================================================================================
| barcode | eventName     | sequenceId | payload
| 1234    | Created       | 0          | shoppingStore: "la redoute", initialAmount: "90 €"
|================================================================================================


[.notes]
--
on ne stocke plus l'état de notre objets, mais les changements qui lui ont été appliqués.

Ça se présente un peu différement avec le nom du changement qui a été appliqué. Ici Created.

L'ordre est garanti par le sequenceId et ensuite en payload, au moins pour l'événement d'init,
vous trouvez à peu près les mêmes informations que sur la version "standard",
à savoir le magasin et le montant initial.

Et si je paye 30 € avec
--

[%notitle.moresmaller]
=== example event sourcing

[cols="4*", options="header"]
|================================================================================================
| barcode | eventName       | sequenceId | payload
| 1234    | Created         | 0          | shoppingStore: "la redoute", initialAmount: "90 €"
| 1234    | PaidAmount      | 1          | amount: "30 €", at: "2025-03-01"
|================================================================================================


[.notes]
--
boum, j'ai un nouvel événement avec un nom différent.
Et tout ce que j'ai besoin de savoir sur cet événement "j'ai payé 30 € avec cette carte", ben c'est le 30 €
et si je dépense les 60 € restants
--

[%notitle.moresmaller]
=== example event sourcing

[cols="4*", options="header"]
|================================================================================================
| barcode | eventName       | sequenceId | payload
| 1234    | Created         | 0          | shoppingStore: "la redoute", initialAmount: "90 €"
| 1234    | PaidAmount      | 1          | amount: "30 €", at: "2025-03-01"
| 1234    | PaidAmount      | 2          | amount: "60 €", at: "2025-03-10"
| 1234    | Exhausted       | 4          | _null_
|================================================================================================
[.notes]
--
J'ai maintenant 2 nouveaux événements, le paidAmount & le exhausted.
--

=== Avantages

- Pas de perte d'information
- Support super simple
- Resilient au nouvelles fonctionnalités

[.notes]
--
L'avantage numéro #1 de cette approche est le fait qu'on ne perd pas d'information.

Et quand je parle d'information, je parle des décisions qui ont été prises par le système.

Le reste en découle, vu qu'on a la liste des événements, ça facilite le support,
qui n'a jamais rêvé de pouvoir dire après un rapide coup d'œil à la liste des événements

> Si on est arrivés dans cet état là, c'est parce qu'il s'est passé ça, puis ça, puis ça et en fait on ne l'avait pas prévu.

Et si le métier vient nous voir en demandant des stats sur l'existant,
et bien vous pouvez leur fournir rapidement et sur tout l'historique.

(je précise sur l'existant, parce que c'est pas magique non plus,
ça ne change rien si on vous demande des stats sur une action qui n'a pas été développée)
--

=== Inconvénients

- Trop d'information
- Pas comme d'habitude
- Inutilisable en l'état

[.notes]
--
côté inconvénient, il y a le fait qu'on explose le besoin de stockage.

là où on n'avait qu'une ligne en base pour un état simple, on se retrouve avec une ligne pour chaque changement.

On n'a pas l'habitude de faire comme ça, et ça peut être déroutant au début.
C'est un point sérieux à prendre en compte, ça demande un temps d'adaptation.

Et le pire c'est que vous n'avez pas d'état exploitable (mais ya des solutions, on verra ça plus tard).
--
